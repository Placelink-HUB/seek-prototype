<?xml version="1.0" encoding="UTF-8"?>
<!--
SEEK
Copyright (C) 2025 placelink

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program. If not, see <https://www.gnu.org/licenses/>.

=========================================================================

상업적 이용 또는 AGPL-3.0의 공개 의무를 면제받기
위해서는, placelink로부터 별도의 상업용 라이선스(Commercial License)를 구매해야 합니다.
For commercial use or to obtain an exemption from the AGPL-3.0 license
requirements, please purchase a commercial license from placelink.
*** 문의처: help@placelink.shop (README.md 참조)
-->
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="biz.placelink.seek.dashboard.service.DashboardMapper">

    <select id="selectAnalysisCount" resultType="analysisStatisticsVO">
        /** selectAnalysisCount : 전체 데이터 분석 수를 조회한다. */
        SELECT
            COUNT(1) AS REQUEST_COUNT,
            COALESCE(SUM(CASE WHEN ANALYSIS_STATUS_CCD = 'COMPLETE' THEN 1 ELSE 0 END), 0) AS COMPLETE_COUNT
        FROM SEEK_ANALYSIS
        WHERE ANALYSIS_MODE_CCD LIKE 'PROXY_%'
            <if test='schDe != null and schDe != ""'>
                AND (CREATE_DT >= #{schDe}::DATE AND (#{schDe}::DATE + INTERVAL '1 DAY') > CREATE_DT)
            </if>
    </select>

    <select id="selectAnalysisResultCount" resultType="analysisStatisticsVO">
        /** selectAnalysisResultCount: 민감정보 탐지 횟수를 조회한다. */
        SELECT
            COUNT(1) AS TOTAL_DETECTION_COUNT,
            COALESCE(SUM(CASE WHEN sar.TOTAL_DETECTION_COUNT > 0 THEN 1 ELSE 0 END), 0) AS DETECTION_COUNT
        FROM SEEK_ANALYSIS sa
            LEFT JOIN SEEK_ANALYSIS_RESULT sar
                ON sa.ANALYSIS_RESULT_ID = sar.ANALYSIS_RESULT_ID
        WHERE sa.ANALYSIS_MODE_CCD LIKE 'PROXY_%'
            AND sa.analysis_status_ccd = 'COMPLETE'
            <if test='schDe != null and schDe != ""'>
                AND (sa.CREATE_DT >= #{schDe}::DATE AND (#{schDe}::DATE + INTERVAL '1 DAY') > sa.CREATE_DT)
            </if>
    </select>

    <select id="selectDetectionStatistics" resultType="analysisStatisticsVO">
        /** selectDetectionStatistics : 탐지 현황을 조회한다. */
        SELECT
            SUM(COALESCE(KOREA_CNT, 0)) + SUM(COALESCE(OTHER_CNT, 0)) AS TOTAL_COUNTRY_COUNT,
            SUM(COALESCE(KOREA_CNT, 0)) AS KOREA_COUNT,
            SUM(COALESCE(OTHER_CNT, 0)) AS OTHER_COUNTRY_COUNT,
            SUM(COALESCE(KOREA_HIGH, 0)) + SUM(COALESCE(KOREA_MID, 0)) + SUM(COALESCE(KOREA_LOW, 0)) AS TOTAL_KOREA_COUNT,
            SUM(COALESCE(OTHER_HIGH, 0)) + SUM(COALESCE(OTHER_MID, 0)) + SUM(COALESCE(OTHER_LOW, 0)) AS TOTAL_OTHER_COUNTRY_COUNT,
            SUM(COALESCE(KOREA_HIGH, 0)) AS KOREA_HIGH_COUNT,
            SUM(COALESCE(KOREA_MID, 0)) AS KOREA_MID_COUNT,
            SUM(COALESCE(KOREA_LOW, 0)) AS KOREA_LOW_COUNT,
            SUM(COALESCE(OTHER_HIGH, 0)) AS OTHER_HIGH_COUNT,
            SUM(COALESCE(OTHER_MID, 0)) AS OTHER_MID_COUNT,
            SUM(COALESCE(OTHER_LOW, 0)) AS OTHER_LOW_COUNT
        FROM (
            SELECT
                COUNT(1) AS KOREA_CNT,
                COALESCE(SUM(CASE WHEN sad.DETECTION_TYPE_CCD = 'high' THEN sad.DETECTION_COUNT ELSE 0 END), 0) AS KOREA_HIGH,
                COALESCE(SUM(CASE WHEN sad.DETECTION_TYPE_CCD = 'mid' THEN sad.DETECTION_COUNT ELSE 0 END), 0) AS KOREA_MID,
                COALESCE(SUM(CASE WHEN sad.DETECTION_TYPE_CCD = 'low' THEN sad.DETECTION_COUNT ELSE 0 END), 0) AS KOREA_LOW,
                NULL AS OTHER_CNT,
                0 AS OTHER_HIGH, 0 AS OTHER_MID, 0 AS OTHER_LOW
            FROM SEEK_ANALYSIS sa
                LEFT JOIN SEEK_PROXY_ANALYSIS spa
                    ON sa.analysis_id = spa.analysis_id
                LEFT JOIN SEEK_ANALYSIS_RESULT sar
                    ON sa.ANALYSIS_RESULT_ID = sar.ANALYSIS_RESULT_ID
                LEFT JOIN SEEK_ANALYSIS_DETECTIONS sad
                    ON sar.ANALYSIS_RESULT_ID = sad.ANALYSIS_RESULT_ID
            WHERE sa.ANALYSIS_MODE_CCD LIKE 'PROXY_%'
                AND sa.analysis_status_ccd = 'COMPLETE'
                /*
                 * 국내를 내부로 임시 변경(!!s2!!)
                AND COALESCE(spa.country_ccd, 'KR') = 'KR'
                */
                AND ANALYSIS_MODE_CCD LIKE 'PROXY_REVERSE_%'
                <if test='schDe != null and schDe != ""'>
                    AND (sa.CREATE_DT >= #{schDe}::DATE AND (#{schDe}::DATE + INTERVAL '1 DAY') > sa.CREATE_DT)
                </if>

            UNION ALL

            SELECT
                NULL AS KOREA_CNT,
                0 AS KOREA_HIGH, 0 AS KOREA_MID, 0 AS KOREA_LOW,
                COUNT(1) AS OTHER_CNT,
                COALESCE(SUM(CASE WHEN sad.DETECTION_TYPE_CCD = 'high' THEN sad.DETECTION_COUNT ELSE 0 END), 0) AS OTHER_HIGH,
                COALESCE(SUM(CASE WHEN sad.DETECTION_TYPE_CCD = 'mid' THEN sad.DETECTION_COUNT ELSE 0 END), 0) AS OTHER_MID,
                COALESCE(SUM(CASE WHEN sad.DETECTION_TYPE_CCD = 'low' THEN sad.DETECTION_COUNT ELSE 0 END), 0) AS OTHER_LOW
            FROM SEEK_ANALYSIS sa
                LEFT JOIN SEEK_PROXY_ANALYSIS spa
                    ON sa.analysis_id = spa.analysis_id
                LEFT JOIN SEEK_ANALYSIS_RESULT sar
                    ON sa.ANALYSIS_RESULT_ID = sar.ANALYSIS_RESULT_ID
                LEFT JOIN SEEK_ANALYSIS_DETECTIONS sad
                    ON sar.ANALYSIS_RESULT_ID = sad.ANALYSIS_RESULT_ID
            WHERE sa.ANALYSIS_MODE_CCD LIKE 'PROXY_%'
                AND sa.analysis_status_ccd = 'COMPLETE'
                /*
                 * 해외를 외부로 임시 변경(!!s2!!)
                AND  COALESCE(spa.country_ccd, 'KR') != 'KR'
                */
                AND ANALYSIS_MODE_CCD LIKE 'PROXY_FORWARD_%'
                <if test='schDe != null and schDe != ""'>
                    AND (sa.CREATE_DT >= #{schDe}::DATE AND (#{schDe}::DATE + INTERVAL '1 DAY') > sa.CREATE_DT)
                </if>
        ) x
    </select>

    <select id="selectRealtimeAnalysisCount" resultType="analysisStatisticsVO">
        /** selectRealtimeAnalysisCount : 실시간 분석 현황을 조회한다. */
        SELECT
            TO_CHAR(DATE_TRUNC('minute', CREATE_DT), 'YYYYMMDDHH24MI') AS MINUTE_GROUP,
            COUNT(1) AS REQUEST_COUNT,
            COALESCE(SUM(CASE WHEN ANALYSIS_STATUS_CCD = 'COMPLETE' THEN 1 ELSE 0 END), 0) AS COMPLETE_COUNT
        FROM SEEK_ANALYSIS
        WHERE ANALYSIS_MODE_CCD LIKE 'PROXY_%'
            <if test='schDe != null and schDe != ""'>
                AND (CREATE_DT >= #{schDe}::DATE AND (#{schDe}::DATE + INTERVAL '1 DAY') > CREATE_DT)
            </if>
        GROUP BY MINUTE_GROUP
        ORDER BY MINUTE_GROUP
    </select>

    <select id="selectLastAnalysisCompleteDateTimeStr" resultType="string">
        /** selectLastAnalysisCompleteDateTimeStr : 최종 분석이 완료된 일시를 조회한다.(문자열) */
        SELECT
            TO_CHAR(MAX(CREATE_DT), 'YYYYMMDDHH24MI')
        FROM SEEK_ANALYSIS
        WHERE ANALYSIS_MODE_CCD LIKE 'PROXY_%'
            AND ANALYSIS_STATUS_CCD = 'COMPLETE'
            <if test='schDe != null and schDe != ""'>
                AND (CREATE_DT >= #{schDe}::DATE AND (#{schDe}::DATE + INTERVAL '1 DAY') > CREATE_DT)
            </if>
    </select>

    <select id="selectTopSensitiveInformation" resultType="analysisStatisticsVO">
        /** selectTopSensitiveInformation : 민감정보 상위 5개 항목을 조회한다. */
        SELECT x.*
        FROM (
                SELECT
                    ssit.DETECTION_TYPE_CCD,
                    SUM(COALESCE(ssi.HIT_COUNT, 0)) AS HIT_COUNT
                FROM SEEK_ANALYSIS sa
                    JOIN SEEK_ANALYSIS_RESULT sar
                        ON sa.ANALYSIS_RESULT_ID = sar.ANALYSIS_RESULT_ID
                    JOIN SEEK_SENSITIVE_INFORMATION_MAPPING ssim
                        ON sar.ANALYSIS_RESULT_ID = ssim.ANALYSIS_RESULT_ID
                    JOIN SEEK_SENSITIVE_INFORMATION ssi
                        ON ssim.SENSITIVE_INFORMATION_ID = ssi.SENSITIVE_INFORMATION_ID
                    JOIN SEEK_SENSITIVE_INFORMATION_TYPES ssit
                        ON ssi.SENSITIVE_INFORMATION_ID = ssit.SENSITIVE_INFORMATION_ID
                WHERE sa.ANALYSIS_MODE_CCD LIKE 'PROXY_%'
                    <if test='schDe != null and schDe != ""'>
                        AND (sa.CREATE_DT >= #{schDe}::DATE AND (#{schDe}::DATE + INTERVAL '1 DAY') > sa.CREATE_DT)
                    </if>
                GROUP BY ssit.DETECTION_TYPE_CCD
        ) x
        ORDER BY x.HIT_COUNT DESC
        LIMIT 5
    </select>

    <select id="selectFileAnalysisInformation" resultType="analysisStatisticsVO">
        /** selectFileAnalysisInformation : 파일 분석 정보를 조회한다. */
        SELECT
            COALESCE(SUM(COALESCE(sfa.FILE_COUNT, 0)), 0) AS ANALYSIS_FILE_COUNT,
            COALESCE(SUM(COALESCE(sfa.TOTAL_FILE_SIZE, 0)), 0) AS ANALYSIS_FILE_SIZE
        FROM SEEK_ANALYSIS sa
            JOIN SEEK_FILE_ANALYSIS sfa
                ON sa.ANALYSIS_ID = sfa.ANALYSIS_ID
                AND sa.ANALYSIS_MODE_CCD = 'DETECTION_FILE'
        WHERE sa.ANALYSIS_STATUS_CCD = 'COMPLETE'
            <if test='schDe != null and schDe != ""'>
                AND (sa.CREATE_DT >= #{schDe}::DATE AND (#{schDe}::DATE + INTERVAL '1 DAY') > sa.CREATE_DT)
            </if>
    </select>

    <select id="selectFileOutboundHistStatusInformation" resultType="analysisStatisticsVO">
        /** selectFileOutboundHistStatusInformation : 파일 외부전송 이력 상태 정보를 조회한다. */
        SELECT
            sfoh.OUTBOUND_STATUS_CCD,
            COUNT(1) AS OUTBOUND_HIST_COUNT,
            SUM(COALESCE(sfoh.TOTAL_FILE_COUNT, 0)) AS OUTBOUND_FILE_COUNT,
            SUM(COALESCE(sfoh.TOTAL_FILE_SIZE, 0)) AS OUTBOUND_FILE_SIZE
        FROM SEEK_FILE_OUTBOUND_HIST sfoh
        <where>
            <if test='schDe != null and schDe != ""'>
                AND (sfoh.CREATE_DT >= #{schDe}::DATE AND (#{schDe}::DATE + INTERVAL '1 DAY') > sfoh.CREATE_DT)
            </if>
        </where>
        GROUP BY sfoh.OUTBOUND_STATUS_CCD
    </select>

    <select id="selectFileOutboundHistChannelInformation" resultType="analysisStatisticsVO">
        /** selectFileOutboundHistChannelInformation : 파일 외부전송 이력 채널 정보를 조회한다. */
        SELECT
            sfoh.OUTBOUND_CHANNEL_CCD,
            cc1.COM_CD_NM AS OUTBOUND_CHANNEL_CCD_NM,
            COUNT(1) AS OUTBOUND_HIST_COUNT
        FROM SEEK_FILE_OUTBOUND_HIST sfoh
            LEFT JOIN SEEK_COM_CD cc1
                ON sfoh.OUTBOUND_CHANNEL_CCD = cc1.COM_CD
                AND cc1.GROUP_CD = 'OUTBOUND_CHANNEL_CCD'
        <where>
            <if test='schDe != null and schDe != ""'>
                AND (sfoh.CREATE_DT >= #{schDe}::DATE AND (#{schDe}::DATE + INTERVAL '1 DAY') > sfoh.CREATE_DT)
            </if>
            <if test='schOutboundStatusCcd != null and schOutboundStatusCcd != ""'>
                AND sfoh.OUTBOUND_STATUS_CCD = #{schOutboundStatusCcd}
            </if>
        </where>
        GROUP BY
            sfoh.OUTBOUND_CHANNEL_CCD,
            cc1.COM_CD_NM
    </select>

    <select id="selectUserIntegratedActivityInformation" resultType="userIntegratedActivityVO">
        /** selectUserIntegratedActivityInformation : 사용자 통합 활동 정보를 조회한다. */
        /* 1.1. 조건에 맞는 에이전트 이력 */
        WITH BASE_AGENT_HIST AS (
            SELECT
                USER_ID,
                EVENT_DT,
                /* 에이전트 기능 상태 */
                CASE
                    /* 모든 기능이 활성화된 경우 */
                    WHEN MINISPY_SYS_YN = 'Y' AND MSPY_USER_EXE_YN = 'Y' AND WFP_BLOCKER_EXE_YN = 'Y' AND CLICK_DOMAIN_AGENT_EXE_YN = 'Y' THEN 'ALL_FUNCTIONAL'
                    /* 하나 이상의 기능이 활성화된 경우 */
                    ELSE 'PARTIAL_FUNCTIONAL'
                END AS AGENT_FUNCTIONALITY_STATUS
            FROM SEEK_AGENT_HEARTBEAT_HIST sahh
            WHERE (EVENT_DT >= #{schDe}::DATE AND (#{schDe}::DATE + INTERVAL '1 DAY') > EVENT_DT)
                AND (
                    /* 에이전트 기능이 하나라도 활성화된 경우만 조회 */
                    MINISPY_SYS_YN = 'Y'
                    OR MSPY_USER_EXE_YN = 'Y'
                    OR WFP_BLOCKER_EXE_YN = 'Y'
                    OR CLICK_DOMAIN_AGENT_EXE_YN = 'Y'
                )
        ),
        /* 1.2. 모든 기능이 활성화된 에이전트 이력 */
        ALL_FUNCTIONAL_AGENT_HIST AS (
            SELECT
                USER_ID,
                'REAL' AS EVENT_TYPE,
                EVENT_DT,
                /* 에이전트 기능 상태 */
                AGENT_FUNCTIONALITY_STATUS
            FROM BASE_AGENT_HIST
            WHERE AGENT_FUNCTIONALITY_STATUS = 'ALL_FUNCTIONAL'
            UNION ALL
            /* BASE_EVENTS에 포함된 모든 USER_ID에 대해 '현재 시간'을 가상 이벤트로 추가 */
            SELECT
                DISTINCT USER_ID,
                'CURRENT' AS EVENT_TYPE,
                /* NOW()를 그대로 사용하면 TIMESTAMPTZ 타입으로 변환 됨 */
                (NOW()::TIMESTAMP) AS EVENT_DT,
                /* 에이전트 기능 상태: 대상아님 */
                'NOT_APPLICABLE' AS AGENT_FUNCTIONALITY_STATUS
            FROM BASE_AGENT_HIST
        ),
        /* 1.3. 하나 이상의 기능이 활성화된 에이전트 이력 */
        ANY_FUNCTIONAL_AGENT_HIST AS (
            SELECT
                USER_ID,
                'REAL' AS EVENT_TYPE,
                EVENT_DT,
                /* 에이전트 기능 상태 */
                AGENT_FUNCTIONALITY_STATUS
            FROM BASE_AGENT_HIST
            WHERE AGENT_FUNCTIONALITY_STATUS IN ('ALL_FUNCTIONAL', 'PARTIAL_FUNCTIONAL')
            UNION ALL
            /* BASE_EVENTS에 포함된 모든 USER_ID에 대해 '현재 시간'을 가상 이벤트로 추가 */
            SELECT
                DISTINCT USER_ID,
                'CURRENT' AS EVENT_TYPE,
                /* NOW()를 그대로 사용하면 TIMESTAMPTZ 타입으로 변환 됨 */
                (NOW()::TIMESTAMP) AS EVENT_DT,
                /* 에이전트 기능 상태: 대상아님 */
                'NOT_APPLICABLE' AS AGENT_FUNCTIONALITY_STATUS
            FROM BASE_AGENT_HIST
        ),
        /* 1.4.1. 모든 기능이 활성화된 에이전트 이력(실제+가상)에 대해 LAG를 적용합니다. */
        ALL_FUNCTIONAL_AGENT_HIST_WITH_LAG AS (
            SELECT
                USER_ID,
                EVENT_TYPE,
                EVENT_DT AS CURRENT_EVENT_DT,
                LAG(EVENT_DT) OVER (
                    PARTITION BY USER_ID
                    ORDER BY EVENT_DT
                ) AS PREVIOUS_EVENT_DT,
                AGENT_FUNCTIONALITY_STATUS
            FROM ALL_FUNCTIONAL_AGENT_HIST
        ),
        /* 1.4.2. 하나 이상의 기능이 활성화된 에이전트 이력(실제+가상)에 대해 LAG를 적용합니다. */
        ANY_FUNCTIONAL_AGENT_HIST_WITH_LAG AS (
            SELECT
                USER_ID,
                EVENT_TYPE,
                EVENT_DT AS CURRENT_EVENT_DT,
                LAG(EVENT_DT) OVER (
                    PARTITION BY USER_ID
                    ORDER BY EVENT_DT
                ) AS PREVIOUS_EVENT_DT,
                AGENT_FUNCTIONALITY_STATUS
            FROM ANY_FUNCTIONAL_AGENT_HIST
        ),
        /* 1.5.1. 모든 기능이 활성화된 에이전트 이력의 최종 시간 차이를 계산합니다. */
        ALL_FUNCTIONAL_AGENT_HIST_INTERVALS AS (
            SELECT
                USER_ID,
                EVENT_TYPE,
                CURRENT_EVENT_DT AS EVENT_DT,
                /* 전체 시간 차이 */
                (CURRENT_EVENT_DT - PREVIOUS_EVENT_DT) AS DISCONNECT_DURATION,
                /* 업무 시간 차이 (UDF 사용) */
                FN_CALCULATE_BUSINESS_HOURS(PREVIOUS_EVENT_DT, CURRENT_EVENT_DT) AS BUSINESS_DISCONNECT_DURATION,
                AGENT_FUNCTIONALITY_STATUS
            FROM ALL_FUNCTIONAL_AGENT_HIST_WITH_LAG
            ORDER BY USER_ID, CURRENT_EVENT_DT
        ),
        /* 1.5.2. 하나 이상의 기능이 활성화된 에이전트 이력의 최종 시간 차이를 계산합니다. */
        ANY_FUNCTIONAL_AGENT_HIST_INTERVALS AS (
            SELECT
                USER_ID,
                EVENT_TYPE,
                CURRENT_EVENT_DT AS EVENT_DT,
                /* 전체 시간 차이 */
                (CURRENT_EVENT_DT - PREVIOUS_EVENT_DT) AS DISCONNECT_DURATION,
                /* 업무 시간 차이 (UDF 사용) */
                FN_CALCULATE_BUSINESS_HOURS(PREVIOUS_EVENT_DT, CURRENT_EVENT_DT) AS BUSINESS_DISCONNECT_DURATION,
                AGENT_FUNCTIONALITY_STATUS
            FROM ANY_FUNCTIONAL_AGENT_HIST_WITH_LAG
            ORDER BY USER_ID, CURRENT_EVENT_DT
        ),
        /* 1.6. 모든 기능이 활성화된 에이전트 이력에 대한 사용자별 통계 요약 */
        ALL_FUNCTIONAL_AGENT_HIST_SUMMARY AS (
            SELECT
                USER_ID,
                /* 첫 번째 이벤트 시각 (BaseEvents 기준) */
                MIN(EVENT_DT) AS ALL_FUNCTIONAL_FIRST_EVENT_DT,
                /* 마지막 이벤트 시각 (BaseEvents 기준, NOW() 제외) */
                MAX(CASE WHEN EVENT_TYPE = 'REAL' THEN EVENT_DT ELSE NULL END) AS ALL_FUNCTIONAL_LAST_EVENT_DT,
                /* 최대 시간 차이 */
                EXTRACT(EPOCH FROM MAX(DISCONNECT_DURATION)) AS ALL_FUNCTIONAL_MAX_DISCONNECT_DURATION,
                /* 최대 업무 시간 차이 */
                EXTRACT(EPOCH FROM MAX(BUSINESS_DISCONNECT_DURATION)) AS ALL_FUNCTIONAL_MAX_BUSINESS_DISCONNECT_DURATION,
                /* 전체 시간 차이의 총합 */
                EXTRACT(EPOCH FROM SUM(DISCONNECT_DURATION)) AS ALL_FUNCTIONAL_TOTAL_DISCONNECT_DURATION,
                /* 업무 시간 차이의 총합 */
                EXTRACT(EPOCH FROM SUM(BUSINESS_DISCONNECT_DURATION)) AS ALL_FUNCTIONAL_TOTAL_BUSINESS_DISCONNECT_DURATION,
                /* DISCONNECT_DURATION이 5분 이상인 간격의 개수 추가 */
                COUNT(CASE WHEN DISCONNECT_DURATION >= INTERVAL '5 minutes' THEN 1 END) AS ALL_FUNCTIONAL_COUNT_DISCONNECT_DURATION_OVER,
                /* BUSINESS_DISCONNECT_DURATION이 5분 이상인 간격의 개수 추가 */
                COUNT(CASE WHEN BUSINESS_DISCONNECT_DURATION >= INTERVAL '5 minutes' THEN 1 END) AS ALL_FUNCTIONAL_COUNT_BUSINESS_DISCONNECT_DURATION_OVER
            FROM ALL_FUNCTIONAL_AGENT_HIST_INTERVALS
            GROUP BY USER_ID
        ),
        /* 1.7. 하나 이상의 기능이 활성화된 에이전트 이력에 대한 사용자별 통계 요약 */
        ANY_FUNCTIONAL_AGENT_HIST_SUMMARY AS (
            SELECT
                USER_ID,
                /* 첫 번째 이벤트 시각 (BaseEvents 기준) */
                MIN(EVENT_DT) AS ANY_FUNCTIONAL_FIRST_EVENT_DT,
                /* 마지막 이벤트 시각 (BaseEvents 기준, NOW() 제외) */
                MAX(CASE WHEN EVENT_TYPE = 'REAL' THEN EVENT_DT ELSE NULL END) AS ANY_FUNCTIONAL_LAST_EVENT_DT,
                /* 최대 시간 차이 */
                EXTRACT(EPOCH FROM MAX(DISCONNECT_DURATION)) AS ANY_FUNCTIONAL_MAX_DISCONNECT_DURATION,
                /* 최대 업무 시간 차이 */
                EXTRACT(EPOCH FROM MAX(BUSINESS_DISCONNECT_DURATION)) AS ANY_FUNCTIONAL_MAX_BUSINESS_DISCONNECT_DURATION,
                /* 전체 시간 차이의 총합 */
                EXTRACT(EPOCH FROM SUM(DISCONNECT_DURATION)) AS ANY_FUNCTIONAL_TOTAL_DISCONNECT_DURATION,
                /* 업무 시간 차이의 총합 */
                EXTRACT(EPOCH FROM SUM(BUSINESS_DISCONNECT_DURATION)) AS ANY_FUNCTIONAL_TOTAL_BUSINESS_DISCONNECT_DURATION,
                /* DISCONNECT_DURATION이 5분 이상인 간격의 개수 추가 */
                COUNT(CASE WHEN DISCONNECT_DURATION >= INTERVAL '5 minutes' THEN 1 END) AS ANY_FUNCTIONAL_COUNT_DISCONNECT_DURATION_OVER,
                /* BUSINESS_DISCONNECT_DURATION이 5분 이상인 간격의 개수 추가 */
                COUNT(CASE WHEN BUSINESS_DISCONNECT_DURATION >= INTERVAL '5 minutes' THEN 1 END) AS ANY_FUNCTIONAL_COUNT_BUSINESS_DISCONNECT_DURATION_OVER
            FROM ANY_FUNCTIONAL_AGENT_HIST_INTERVALS
            GROUP BY USER_ID
        ),
        /* 1.8. 최종 에이전트 결과 보고서 */
        FINAL_AGENT_ACTIVITY_REPORT AS (
            SELECT
                COALESCE(a.USER_ID, b.USER_ID) AS USER_ID,
                /* ALL_FUNCTIONAL 결과 */
                b.ALL_FUNCTIONAL_FIRST_EVENT_DT,
                b.ALL_FUNCTIONAL_LAST_EVENT_DT,
                b.ALL_FUNCTIONAL_MAX_DISCONNECT_DURATION,
                b.ALL_FUNCTIONAL_MAX_BUSINESS_DISCONNECT_DURATION,
                b.ALL_FUNCTIONAL_TOTAL_DISCONNECT_DURATION,
                b.ALL_FUNCTIONAL_TOTAL_BUSINESS_DISCONNECT_DURATION,
                b.ALL_FUNCTIONAL_COUNT_DISCONNECT_DURATION_OVER,
                b.ALL_FUNCTIONAL_COUNT_BUSINESS_DISCONNECT_DURATION_OVER,
                /* ANY_FUNCTIONAL 결과 */
                a.ANY_FUNCTIONAL_FIRST_EVENT_DT,
                a.ANY_FUNCTIONAL_LAST_EVENT_DT,
                a.ANY_FUNCTIONAL_MAX_DISCONNECT_DURATION,
                a.ANY_FUNCTIONAL_MAX_BUSINESS_DISCONNECT_DURATION,
                a.ANY_FUNCTIONAL_TOTAL_DISCONNECT_DURATION,
                a.ANY_FUNCTIONAL_TOTAL_BUSINESS_DISCONNECT_DURATION,
                a.ANY_FUNCTIONAL_COUNT_DISCONNECT_DURATION_OVER,
                a.ANY_FUNCTIONAL_COUNT_BUSINESS_DISCONNECT_DURATION_OVER
            FROM ANY_FUNCTIONAL_AGENT_HIST_SUMMARY a
            FULL JOIN ALL_FUNCTIONAL_AGENT_HIST_SUMMARY b
                ON COALESCE(a.USER_ID, 'UNKNOWN') = COALESCE(b.USER_ID, 'UNKNOWN')
        ),
        /* 2. 언마스킹 결과 보고서 */
        UNMASK_REPORT AS (
            SELECT
                USER_ID,
                COUNT(1) AS UNMASK_COUNT,
                SUM(CASE WHEN NOT FN_IS_BUSINESS_HOUR(CREATE_DT::TIMESTAMPTZ) THEN 1 ELSE 0 END) AS UNMASK_NON_BUSINESS_COUNT,
                SUM(MASK_COUNT) AS UNMASK_ITEM_COUNT,
                SUM(CASE WHEN NOT FN_IS_BUSINESS_HOUR(CREATE_DT::TIMESTAMPTZ) THEN MASK_COUNT ELSE 0 END) AS UNMASK_NON_BUSINESS_ITEM_COUNT
            FROM SEEK_MASK_HIST
            WHERE MASK_MODE_CCD = 'unmask'
                AND (CREATE_DT >= #{schDe}::DATE AND (#{schDe}::DATE + INTERVAL '1 DAY') > CREATE_DT)
            GROUP BY USER_ID
        ),
        /* 3.1. 조건에 맞는 파일 외부전송 이력 */
        BASE_FILE_OUTBOUND_HIST AS (
            SELECT *
            FROM SEEK_FILE_OUTBOUND_HIST
            WHERE (EVENT_DT >= #{schDe}::DATE AND (#{schDe}::DATE + INTERVAL '1 DAY') > EVENT_DT)
        ),
        /* 3.2. 파일 외부전송 이력 요약 */
        FILE_OUTBOUND_SUMMARY AS (
            SELECT
                USER_ID,
                COUNT(1) AS FILE_OUTBOUND_TOTAL_COUNT,
                SUM(CASE WHEN OUTBOUND_STATUS_CCD = 'SENT' THEN 1 ELSE 0 END) AS FILE_OUTBOUND_SENT_COUNT,
                SUM(CASE WHEN OUTBOUND_STATUS_CCD = 'SENT' AND NOT FN_IS_BUSINESS_HOUR(CREATE_DT::TIMESTAMPTZ) THEN 1 ELSE 0 END) AS FILE_OUTBOUND_NON_BUSINESS_SENT_COUNT,
                SUM(CASE WHEN OUTBOUND_STATUS_CCD = 'BLOCKED' THEN 1 ELSE 0 END) AS FILE_OUTBOUND_BLOCKED_COUNT,
                SUM(CASE WHEN OUTBOUND_STATUS_CCD = 'BLOCKED' AND NOT FN_IS_BUSINESS_HOUR(CREATE_DT::TIMESTAMPTZ) THEN 1 ELSE 0 END) AS FILE_OUTBOUND_NON_BUSINESS_BLOCKED_COUNT,
                SUM(TOTAL_FILE_COUNT) AS FILE_OUTBOUND_TOTAL_FILE_COUNT,
                SUM(CASE WHEN OUTBOUND_STATUS_CCD = 'SENT' THEN TOTAL_FILE_COUNT ELSE 0 END) AS FILE_OUTBOUND_SENT_FILE_COUNT,
                SUM(CASE WHEN OUTBOUND_STATUS_CCD = 'SENT' AND NOT FN_IS_BUSINESS_HOUR(CREATE_DT::TIMESTAMPTZ) THEN TOTAL_FILE_COUNT ELSE 0 END) AS FILE_OUTBOUND_NON_BUSINESS_SENT_FILE_COUNT,
                SUM(CASE WHEN OUTBOUND_STATUS_CCD = 'BLOCKED' THEN TOTAL_FILE_COUNT ELSE 0 END) AS FILE_OUTBOUND_BLOCKED_FILE_COUNT,
                SUM(CASE WHEN OUTBOUND_STATUS_CCD = 'BLOCKED' AND NOT FN_IS_BUSINESS_HOUR(CREATE_DT::TIMESTAMPTZ) THEN TOTAL_FILE_COUNT ELSE 0 END) AS FILE_OUTBOUND_NON_BUSINESS_BLOCKED_FILE_COUNT,
                SUM(TOTAL_FILE_SIZE) AS FILE_OUTBOUND_TOTAL_FILE_SIZE,
                SUM(CASE WHEN OUTBOUND_STATUS_CCD = 'SENT' THEN TOTAL_FILE_SIZE ELSE 0 END) AS FILE_OUTBOUND_SENT_FILE_SIZE,
                SUM(CASE WHEN OUTBOUND_STATUS_CCD = 'SENT' AND NOT FN_IS_BUSINESS_HOUR(CREATE_DT::TIMESTAMPTZ) THEN TOTAL_FILE_SIZE ELSE 0 END) AS FILE_OUTBOUND_NON_BUSINESS_SENT_FILE_SIZE,
                SUM(CASE WHEN OUTBOUND_STATUS_CCD = 'BLOCKED' THEN TOTAL_FILE_SIZE ELSE 0 END) AS FILE_OUTBOUND_BLOCKED_FILE_SIZE,
                SUM(CASE WHEN OUTBOUND_STATUS_CCD = 'BLOCKED' AND NOT FN_IS_BUSINESS_HOUR(CREATE_DT::TIMESTAMPTZ) THEN TOTAL_FILE_SIZE ELSE 0 END) AS FILE_OUTBOUND_NON_BUSINESS_BLOCKED_FILE_SIZE
            FROM BASE_FILE_OUTBOUND_HIST
            GROUP BY USER_ID
        ),
        /* 3.3. 파일 외부전송 보고서 */
        FILE_OUTBOUND_REPORT AS (
            SELECT
                fos.*,
                fj.FILE_OUTBOUND_MAX_DUPLICATE_FILE_COUNT
            FROM FILE_OUTBOUND_SUMMARY fos
                FULL JOIN (
                    SELECT
                        USER_ID,
                        MAX(DUPLICATE_FILE_COUNT) AS FILE_OUTBOUND_MAX_DUPLICATE_FILE_COUNT
                    FROM (
                        SELECT
                            USER_ID,
                            TOTAL_FILE_COUNT,
                            TOTAL_FILE_SIZE,
                            COUNT(1) AS DUPLICATE_FILE_COUNT
                        FROM BASE_FILE_OUTBOUND_HIST
                        GROUP BY
                            USER_ID,
                            TOTAL_FILE_COUNT,
                            TOTAL_FILE_SIZE
                    )
                    GROUP BY USER_ID
                ) fj
                    ON COALESCE(fos.USER_ID, 'UNKNOWN') = COALESCE(fj.USER_ID, 'UNKNOWN')
        )
        SELECT *
        FROM FINAL_AGENT_ACTIVITY_REPORT far
            FULL JOIN UNMASK_REPORT ur
                ON COALESCE(far.USER_ID, 'UNKNOWN') = COALESCE(ur.USER_ID, 'UNKNOWN')
            FULL JOIN FILE_OUTBOUND_REPORT fobr
                ON COALESCE(far.USER_ID, 'UNKNOWN') = COALESCE(fobr.USER_ID, 'UNKNOWN')
        ORDER BY far.USER_ID
    </select>

</mapper>
