CREATE OR REPLACE FUNCTION FN_PREPARE_TEXT_CONTENT_FOR_ANALYSIS()
    RETURNS TRIGGER AS $$
DECLARE
    analysis_uuid UUID := GEN_RANDOM_UUID();
    table_name TEXT := TG_ARGV[0];            -- 대상 테이블명
    column_name TEXT := TG_ARGV[1];           -- 대상 컬럼명
    pk_column_names TEXT := TG_ARGV[2];       -- 프라이머리 키 컬럼명들 (복합키인 경우 쉼표로 구분한다.)
    pk_columns TEXT[];                        -- 프라이머리 키 컬럼 배열
    column_value TEXT;                        -- 대상 컬럼 값
    where_clause TEXT := '';                  -- 동적 WHERE 조건
    i INT := 1;                               -- 파라미터 인덱스
BEGIN
    /**
     * table_name 테이블의 column_name 컬럼 내용을 SEEK_ANALYSIS 테이블로 이동하고,
     * 분석을 위한 준비 작업을 수행하며 table_name 테이블의 column_name 컬럼에는 해당 UUID 를 반영한다.
     */

    -- 프라이머리 키 컬럼명을 배열로 변환 (쉼표로 구분된 문자열을 분리)
    pk_columns := STRING_TO_ARRAY(pk_column_names, ',');

    -- WHERE 조건 동적 생성 (디버깅용으로 유지, 필요 시 사용)
    FOR i IN 1..ARRAY_LENGTH(pk_columns, 1) LOOP
            IF i > 1 THEN
                where_clause := where_clause || ' AND ';
            END IF;
            where_clause := where_clause || format('%I = $2.%I', TRIM(pk_columns[i]), TRIM(pk_columns[i]));
        END LOOP;

    -- 동적으로 대상 컬럼 값 가져오기 (NEW에서 직접 가져옴)
    EXECUTE format('SELECT ($1).%I', column_name)
        INTO column_value
        USING NEW;

    -- SEEK_ANALYSIS 테이블에 데이터 삽입
    INSERT INTO SEEK_ANALYSIS (
        ANALYSIS_ID,
        ANALYSIS_TYPE_CCD,
        ANALYSIS_STATUS_CCD,
        TARGET_INFORMATION,
        ANALYSIS_CONTENT,
        ANALYSIS_START_DT,
        ANALYSIS_END_DT,
        ANALYSIS_TIME,
        CREATE_DT
    ) VALUES (
         analysis_uuid,
         'TEXT',
         'WAIT',
         table_name || '.' || column_name,
         column_value,
         NULL,
         NULL,
         NULL,
         CLOCK_TIMESTAMP()
     );

    -- NEW 의 대상 컬럼에 UUID 반영
    NEW := NEW #= hstore(column_name, '$WT{' || analysis_uuid || '}');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;